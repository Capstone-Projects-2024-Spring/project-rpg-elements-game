"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[6070],{7780:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=n(85893),o=n(11151);const s={},a=void 0,i={id:"system-architecture/procedural-generation",title:"procedural-generation",description:"Procedural Generation Algorithm",source:"@site/docs/system-architecture/procedural-generation.md",sourceDirName:"system-architecture",slug:"/system-architecture/procedural-generation",permalink:"/project-rpg-elements-game/docs/system-architecture/procedural-generation",draft:!1,unlisted:!1,editUrl:"https://github.com/Capstone-Projects-2024-Spring/project-rpg-elements-game/edit/main/documentation/docs/system-architecture/procedural-generation.md",tags:[],version:"current",lastUpdatedBy:"Alex McGinn",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Architecture",permalink:"/project-rpg-elements-game/docs/system-architecture/Architecture"},next:{title:"sequence-diagrams",permalink:"/project-rpg-elements-game/docs/system-architecture/sequence-diagrams"}},h={},l=[];function c(e){const t={li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Procedural Generation Algorithm"}),"\n",(0,r.jsx)(t.p,{children:"There are currently two ideas for the algorithm that may be implemented. The first is an algorithm that was created to match how a game, Spelunky, created their map. The algorithm is a simple directional checker.\nWhat this means is that at its base it looks to find if a portion of the map can be spawned to the left or the right of the previous room. If this is the case then it will spawn a room there and continue the process until it reaches the maximum Y distance.\nThe maximum Y distance describes the \u201cheight\u201d of the map or the lower bound. If the final block spawns on the max Y block the level generation code will then stop and there should be a path from the spawn point to the end.\nHowever, this does not take any of the directional openings into account. The directional openings are simple values, 0 for a left and right room opening, 1 for left, right, and bottom openings, 2 for left, right, top, and bottom openings, and 3\nfor left, right, top, and bottom openings. For left and right room spawns, the room choice does not matter as no room will block the spawn, therefore the script is told to just pick a random room from zero to three. For bottom movement, the script is\ntold to choose either 2 or 3 as they have top and bottom openings."}),"\n",(0,r.jsx)(t.p,{children:"The second algorithm is an original algorithm that will be able to assign the rooms numerical values based on where the walls are then it will use graph theory to stitch them together in a way that ensures there are no spaces that are inaccessible. The algorithm will follow this layout:"}),"\n",(0,r.jsx)(t.p,{children:"Phase 1 \u2013 Generate an M by N Maze"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Generate an M by N lattice graph for the rooms, call it R."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Generate an (M+1) by (N+1) lattice graph for the walls around each room, call it W."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Give all the edges of R and random weight."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Construct a minimum spanning tree (MST) from the edges of R, call it T."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Remove all the edges of W that intersect an edge of the MST of R."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"We now have a maze that ensures every room on the map is accessible via some path from any other room."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Phase 2 \u2013 Increase Connectivity"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Get a list of all the interior edges of W."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Select a portion of the edges at random and remove them."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"For each removed edge from W, add the corresponding edge to T."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Phase 3 \u2013 Calculate Room Types"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Assign the four walls of a room a value that is a power of 2, [1=top,2=right,4=bottom,8=left]."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"For each room in R, find the edges in W that correspond to the room."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Sum the values of the walls surrounding the room."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Assign that value to the node in R."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"The MST was originally our paths through the maze, but with the additional edges added it is now a graph of the increased connectivity caused by removing the random walls."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Phase 5 \u2013 Choose Player\u2019s Starting Room and Boss Room"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Set all the edge weights of T to 1."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Use Dijkstra's Algorithm to compute the shortest path between all nodes of T."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"From the resulting matrix, find the maximum value to get the longest path between any of the nodes."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Take the two nodes that make the longest path and assign one as the players\u2019 starting point, and the Boss room at the other."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"This algorithm will ensure that every room on the map is accessible and that there are no holes in the exterior walls. From phase 5, we have also ensured that the boss is placed as far away from the players as possible."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Phase 6 \u2013 Build the Map"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"For each node in R, get the value calculated in Phase 3."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Select a room from a bank of that type."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Spawn that room in the game space preserving the structure of R."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>a});var r=n(67294);const o={},s=r.createContext(o);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);